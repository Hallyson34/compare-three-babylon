<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico" />
    <title>Babylon.js Hintze-Hall</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #backButton {
        position: absolute;
        top: 60px;
        left: 5px;
        padding: 12px;
        background-color: rgba(0, 0, 0, 0.73);
        color: white;
        border: 1px solid white;
        border-radius: 4px;
        cursor: pointer;
        z-index: 1;
      }
      #backButton:hover {
        background-color: rgba(0, 0, 0, 0.7);
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.28.0/babylon.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.28.0/babylon.glTF2FileLoader.min.js"></script>
  </head>

  <body>
    <button id="backButton" onclick="window.location.href='/site/index.html'">
      Voltar
    </button>
    <canvas id="renderCanvas"></canvas>
  </body>

  <script>
    const canvas = document.getElementById("renderCanvas");

    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1);

    new BABYLON.HemisphericLight(
      "hemisphericLight",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );

    new BABYLON.DirectionalLight(
      "directionalLight",
      new BABYLON.Vector3(-1, -1, -1),
      scene
    );

    let gltfModel;
    BABYLON.SceneLoader.ImportMesh(
      "",
      "https://github.com/Hallyson34/compare-three-babylon/releases/download/v1/",
      "hintze-hall.glb",
      scene,
      (meshes) => {
        gltfModel = meshes[0];
        gltfModel.position = BABYLON.Vector3.Zero();
      },
      undefined,
      (error) => {
        console.error("Erro ao carregar o modelo:", error);
      }
    );

    const camera = new BABYLON.UniversalCamera(
      "camera",
      new BABYLON.Vector3(0, 2, 5),
      scene
    );
    camera.setTarget(new BABYLON.Vector3(0, 6, 0));

    let frames = 0;
    let lastTime = 0;
    let carry = 0;

    const fpsLogs = [];

    function updateFPS() {
      if (fpsLogs.length >= 60) return;

      const now = performance.now();

      const delta = now - lastTime;
      lastTime = now;

      carry += delta;
      frames++;

      if (carry >= 1000) {
        const fps = (frames * 1000) / carry;
        fpsLogs.push(Number(fps.toFixed(1)));

        carry -= 1000;
        frames = 0;

        if (fpsLogs.length >= 60) {
          console.log("60 medições concluídas:", fpsLogs);
        }
      }
    }

    let memLogs = [];
    let memInterval;

    function updateMemory() {
      if (!performance.memory) {
        console.warn("performance.memory não suportado neste navegador.");
        return;
      }

      const mb = performance.memory.usedJSHeapSize / 1024 / 1024;
      memLogs.push(Number(mb.toFixed(2)));

      if (memLogs.length >= 60) {
        clearInterval(memInterval);
        console.log("60 medições de MB concluídas:", memLogs);
      }
    }
    memInterval = setInterval(updateMemory, 1000);

    let angle = 0;
    const radius = 6;

    engine.runRenderLoop(() => {
      angle -= 0.002;

      camera.position.x = radius * Math.sin(angle);
      camera.position.z = radius * Math.cos(angle);
      camera.position.y = 6;
      camera.setTarget(new BABYLON.Vector3(0, 6, 0));

      scene.render();
      updateFPS();
    });
  </script>
</html>
