<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico" />
    <title>Babylon.js Trees</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      #backButton {
        position: absolute;
        top: 50px;
        left: 5px;
        padding: 12px;
        background-color: rgba(0, 0, 0, 0.73);
        color: white;
        border: 1px solid white;
        border-radius: 4px;
        cursor: pointer;
        z-index: 1;
      }
      #backButton:hover {
        background-color: rgba(0, 0, 0, 0.7);
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.28.0/babylon.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.28.0/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
  </head>

  <body>
    <button id="backButton" onclick="window.location.href='/site/index.html'">
      Voltar
    </button>
    <canvas id="renderCanvas"></canvas>
  </body>

  <script>
    const canvas = document.getElementById("renderCanvas");

    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1);

    new BABYLON.HemisphericLight(
      "hemisphericLight",
      new BABYLON.Vector3(1, 1, 0),
      scene
    );

    const directionalLight = new BABYLON.DirectionalLight(
      "dirLight",
      new BABYLON.Vector3(-1, -2, -1),
      scene
    );

    let gltfModel;
    BABYLON.SceneLoader.ImportMesh(
      "",
      "https://github.com/Hallyson34/compare-three-babylon/releases/download/v1/",
      "low_poly_tree_scene_free.glb",
      scene,
      (meshes) => {
        gltfModel = meshes[0];
        gltfModel.position = BABYLON.Vector3.Zero();
      },
      undefined,
      (error) => {
        console.error("Erro ao carregar o modelo:", error);
      }
    );

    const stats = new Stats();
    document.body.appendChild(stats.dom);

    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      Math.PI / 2,
      Math.PI / 2.2,
      5,
      BABYLON.Vector3.Zero(),
      scene
    );
    camera.fov = BABYLON.Tools.ToRadians(75);
    camera.minZ = 0.1;
    camera.maxZ = 1000;

    let frames = 0;
    let lastTime = 0;
    let carry = 0;

    const fpsLogs = [];

    function updateFPS() {
      if (fpsLogs.length >= 60) return;

      const now = performance.now();

      const delta = now - lastTime;
      lastTime = now;

      carry += delta;
      frames++;

      if (carry >= 1000) {
        const fps = (frames * 1000) / carry;
        fpsLogs.push(Number(fps.toFixed(1)));

        carry -= 1000;
        frames = 0;

        if (fpsLogs.length >= 60) {
          console.log("60 medições concluídas:", fpsLogs);
        }
      }
    }

    engine.runRenderLoop(() => {
      stats.begin();
      camera.alpha += 0.003;

      scene.render();
      stats.end();
      updateFPS();
    });
  </script>
</html>
