<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico" />
    <title>Three.js Trees</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #backButton {
        position: absolute;
        top: 50px;
        left: 5px;
        padding: 12px;
        background-color: rgba(0, 0, 0, 0.73);
        color: white;
        border: 1px solid white;
        border-radius: 4px;
        cursor: pointer;
        z-index: 1;
      }
      #backButton:hover {
        background-color: rgba(0, 0, 0, 0.7);
      }
    </style>
  </head>

  <body>
    <button id="backButton" onclick="window.location.href='/site/index.html'">
      Voltar
    </button>
  </body>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.180.0";
    import { GLTFLoader } from "https://esm.sh/three@0.180.0/examples/jsm/loaders/GLTFLoader.js";

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xb0e0e6);

    const ambientLight = new THREE.HemisphereLight();
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight();
    scene.add(directionalLight);

    const loader = new GLTFLoader();
    loader.load("/models/low_poly_tree_scene_free.glb", (gltf) =>
      scene.add(gltf.scene)
    );

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 2, 5);

    let frames = 0;
    let lastTime = 0;
    let carry = 0;
    const fpsLogs = [];

    function updateFPS() {
      if (fpsLogs.length >= 60) return;

      const now = performance.now();

      const delta = now - lastTime;
      lastTime = now;

      carry += delta;
      frames++;

      if (carry >= 1000) {
        const fps = (frames * 1000) / carry;
        fpsLogs.push(Number(fps.toFixed(1)));

        carry -= 1000;
        frames = 0;

        if (fpsLogs.length >= 60) {
          console.log("60 medições de FPS concluídas:", fpsLogs);
        }
      }
    }

    let memLogs = [];
    let memInterval;

    function updateMemory() {
      if (!performance.memory) {
        console.warn("performance.memory não suportado neste navegador.");
        return;
      }

      const mb = performance.memory.usedJSHeapSize / 1024 / 1024;
      memLogs.push(Number(mb.toFixed(2)));

      if (memLogs.length >= 60) {
        clearInterval(memInterval);
        console.log("60 medições de MB concluídas:", memLogs);
      }
    }
    memInterval = setInterval(updateMemory, 1000);

    let angle = 0;
    const radius = 5;

    function animate() {
      angle += 0.003;
      camera.position.x = radius * Math.sin(angle);
      camera.position.z = radius * Math.cos(angle);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      renderer.render(scene, camera);

      updateFPS();

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</html>
